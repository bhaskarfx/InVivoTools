function sgs = loadstim(stochasticgridstim3D)% cc 2010-04-06: adjusted stochastic grid stim for zalman ZM-M220WStimWindowGlobals;% Getting, changing and renaming the parametersSGSstim = unloadstim(stochasticgridstim3D);   % unload old version before loadingSGSp = stochasticgridstim3D.SGSp;   % load parameters from stochasticgridstim3D.mdP = getdisplayprefs(stochasticgridstim3D.stimulus);dPs = struct(dP);width   = SGSp.rect(3) - SGSp.rect(1);  %The width of stimulus windowheight  = SGSp.rect(4) - SGSp.rect(2);  %The height of the window.stimsizeL =[SGSp.posL(3) - SGSp.posL(1); SGSp.posL(4) - SGSp.posL(2)];stimsizeR =[SGSp.posR(3) - SGSp.posR(1); SGSp.posR(4) - SGSp.posR(2)];% Set up grid% General valuesX = SGSp.pixSizeL(1);  %Remove when finished!!!Y = SGSp.pixSizeL(2);  %Remove when finished!!!i = 1:width;              x = fix((i-1)/X)+1;     i = 1:height;             y = fix((i-1)/Y)+1;        XY = x(end)*y(end); % Left valuesXL = SGSp.pixSizeL(1);YL = SGSp.pixSizeL(2);i = 1:stimsizeL(1);              xl = fix((i-1)/XL)+1;     i = 1:stimsizeL(2);             yl = fix((i-1)/YL)+1;        XYL = xl(end)*yl(end); % Right valuesXR = SGSp.pixSizeR(1);YR = SGSp.pixSizeR(2);i = 1:stimsizeR(1);              xr = fix((i-1)/XR)+1;     i = 1:stimsizeR(2);             yr = fix((i-1)/YR)+1;        XYR = xr(end)*yr(end); switch SGSp.eyes    case 0;        gridL = (  [(xl-1)*yl(end)]'*ones(1,length(yl)) + ones(1,length(xl))'*yl )';        gridL(1:2:end,:)=0;        grid= zeros(height,width);        grid(SGSp.posL(2)+1:SGSp.posL(4),SGSp.posL(1)+1:SGSp.posL(3)) = gridL;    case 1;        gridR = (  [(xr-1)*yr(end)]'*ones(1,length(yr)) + ones(1,length(xr))'*yr )';        gridR(2:2:end,:)=0;        grid= zeros(height,width);        grid(SGSp.posR(2)+1:SGSp.posR(4),SGSp.posR(1)+1:SGSp.posR(3))= gridR;    case 2;         gridR = (  [(xr-1)*yr(end)]'*ones(1,length(yr)) + ones(1,length(xr))'*yr )';        gridR(2:2:end,:)=0;        gridL = (  [(xl-1)*yl(end)]'*ones(1,length(yl)) + ones(1,length(xl))'*yl  )';        gridL(1:2:end,:)=0;        grid= zeros(height,width);        grid(SGSp.posL(2)+1:SGSp.posL(4),SGSp.posL(1)+1:SGSp.posL(3)) = gridL;        grid(SGSp.posR(2)+1:SGSp.posR(4),SGSp.posR(1)+1:SGSp.posR(3)) = ...        grid(SGSp.posR(2)+1:SGSp.posR(4),SGSp.posR(1)+1:SGSp.posR(3))+ gridR;endgridR = zeros(SGSp.posR(4)-SGSp.posR(2),SGSp.posR(3)-SGSp.posR(1));gridL = zeros(SGSp.posL(4)-SGSp.posL(2),SGSp.posL(3)-SGSp.posL(1));%Extra martices which are used for generating a movie if the amount of%pixels in the image is more than 256gr = reshape(1:stimsizeR(1)*stimsizeR(2),stimsizeR(2),stimsizeR(1));gl = reshape(1:stimsizeL(1)*stimsizeL(2),stimsizeL(2),stimsizeL(1));  % Another matrix if numbers is created with each pizel numbered  % sequentially in columns from top to bottomcornerR = zeros(YR,XR); cornerR(1) = 1;cornerL = zeros(YL,XL); cornerL(1) = 1;  % Creates a grid of zero's as large as one of the squares wthith the first  % value as 1  ccr=reshape(repmat(cornerR,stimsizeR(2)/YR,stimsizeR(1)/XR).*gr,stimsizeR(1)*stimsizeR(2),1);ccl=reshape(repmat(cornerL,stimsizeL(2)/YL,stimsizeL(1)/XL).*gl,stimsizeL(1)*stimsizeL(2),1);  % The repmat(Matrix,m,n) part replicates a (predefined) matrix into a larger m by n  % times the original matrix. Matrix in which all corners are 1 is multiplied by  % the matrix g which was a matrix with each pixel numbered. Now all corners  % have numered pixels. This matrix is subsequently reshaped into a long  % column with width 1. cornersR = ccr(find(ccr))';cornersL = ccl(find(ccl))';  % find function finds the linear indices of non-zero values. In the cc()  % the output represents the actual values of these indices from matrix g.   % ' Transposes this back to a row instead of a column.footprintR = reshape(gr(1:YR,1:XR),XR*YR,1)-1;footprintL = reshape(gl(1:YL,1:XL),XL*YL,1)-1;  % creates a column with the values of the first X by Y block of matrix gindsR=ones(1,XR*YR)'*cornersR+footprintR*ones(1,XYR);indsL=ones(1,XL*YL)'*cornersL+footprintL*ones(1,XYL);  % inds = a matrix in which each square has every pixel sequentially  % numbered from top to bottom, left to right.   % ex.    1  3  9   11  %        2  4  10  12   %        5  7  13  15  %        6  8  14  16zr = 1:XYR;zl = 1:XYL;  % z = a row of numbers from 1 to the total amount of squaresclut_bg = repmat(SGSp.BG,256,1);  % clut_bg = a matrix with the background colour repeated 256 times in a  % 3-wide columndepth = 8;l = length(SGSp.distL);  % l= the length of the probabilities arrayclut_usage = [ 1 ones(1,l) zeros(1,255-l) ]';  % Creates a long one-column matrix with a one, then the amount of ones  % equal to the amount of different colours and then 254 zero's     probsR = cumsum(SGSp.distR(1:end))';          % Cumulative values in probabilitiesprobsR = probsR ./ probsR(end);               % Cumulative proportionsphsR = ones(XYR,1) * probsR;                  % Matrix with columns containing max boundary of cum probplsR = [ zeros(XYR,1) phsR(:,1:end-1)];       % Matrix with columns containing min boundary of cum prob probsL = cumsum(SGSp.distL(1:end))';          % Cumulative values in probabilitiesprobsL = probsL ./ probsL(end);               % Cumulative proportionsphsL = ones(XYL,1) * probsL;                  % Matrix with columns containing max boundary of cum probplsL = [ zeros(XYL,1) phsL(:,1:end-1)];       % Matrix with columns containing min boundaryrand('state',SGSp.randState);dP = getdisplayprefs(stochasticgridstim3D.stimulus);dPs = struct(dP);%Choose right or left sizes when bith eyes image neededif XYR >= XYL;    XYC=XYR;else XYR < XYL;    XYC=XYL;end%If number of squares small enough, use one image and array of CLUTs, one%frame per columnif ((XYR<253)&&(XYL<253)&&(~dPs.forceMovie));	displayType = 'CLUTanim';	displayProc = 'standard';     	clut = cell(SGSp.N,1);   	switch SGSp.eyes        case 0            for i=1:SGSp.N;                f = rand(XYL,1) * ones(1,length(SGSp.distL));                [I,J] = find(f>plsL & f<=phsL);                [y,is] = sort(I);                clut{i} = ([ SGSp.BG ; SGSp.valuesL(J(is),:);...                    repmat(SGSp.BG,255-XYL,1);]);            end        case 1            for i=1:SGSp.N;                f = rand(XYR,1) * ones(1,length(SGSp.distR));                [I,J] = find(f>plsR & f<=phsR);                [y,is] = sort(I);                clut{i} = ([ SGSp.BG ; SGSp.valuesR(J(is),:);...                    repmat(SGSp.BG,255-XYR,1);]);            end        case 2   %Cannot yet do images that are different, takes right image for XY, pls and phs            for i=1:SGSp.N,                          f = rand(XYR,1) * ones(1,length(SGSp.distR));                [I,J] = find(f>plsR & f<=phsR);                [y,is] = sort(I);                clut{i} = ([ SGSp.BG ; SGSp.valuesR(J(is),:);repmat(SGSp.BG,255-XYR,1);]);            end%         case 2 & 0;    % Does not work yet: will not use the different clut's%             for i=1:SGSp.N,          %                 fr = rand(XYR,1) * ones(1,length(SGSp.distR));%                 [I,J] = find(f>plsR & f<=phsR);%                 [y,is] = sort(I);%                 clutr{i} = ([ SGSp.BG ; SGSp.valuesR(J(is),:);repmat(SGSp.BG,255-XYR,1);]);%                 fl = rand(XYL,1) * ones(1,length(SGSp.distL));%                 [I,J] = find(f>plsL & f<=phsL);%                 [y,is] = sort(I);%                 clutl{i} = ([ SGSp.BG ; SGSp.valuesL(J(is),:);repmat(SGSp.BG,255-XYL,1);]);%             end    end	ShowStimScreen	offscreen = screen(StimWindow,'OpenOffscreenWindow',0,[0 0 width height]);	screen(offscreen,'PutImage',grid,SGSp.rect);else    % use one CLUT and many images    ShowStimScreen    displayType = 'Movie';    displayProc = 'standard';    clut = ([ SGSp.BG; SGSp.valuesR(1:l,:); repmat(SGSp.BG,255-l,1);]);    offscreen = zeros(1,SGSp.N);    for i=1:SGSp.N        offscreen(i) = screen(StimWindow,'OpenOffscreenWindow',255,SGSp.rect);        image = repmat(uint8(0),size(grid));        if SGSp.eyes==0||SGSp.eyes==2;            I = 1:XYL; % list of all block numbers            Je = ones(1,size(indsL,1)); % vector of length of number of pixels in block            f = rand(XYL,1) * ones(1,length(SGSp.distL)); %f=three columns containing random numbers            [I,J] = find(f>plsL & f<=phsL);            [y,is] = sort(I);            imageL = repmat(uint8(0),size(gridL));            imageL(indsL(:,I)) = (J(is) * Je)';            imageL(1:2:end,:)=0;     %(uneven pixels in y-range turn to bg)            image(SGSp.posL(2)+1:SGSp.posL(4),SGSp.posL(1)+1:SGSp.posL(3)) = imageL;        end        if SGSp.eyes==1||SGSp.eyes==2;            I = 1:XYR; % list of all block numbers            Je = ones(1,size(indsR,1)); % vector of length of number of pixels in block            f = rand(XYR,1) * ones(1,length(SGSp.distR)); %f=three columns containing random numbers            [I,J] = find(f>plsR & f<=phsR);            [y,is] = sort(I);            imageR = repmat(uint8(0),size(gridR));            imageR(indsR(:,I)) = (J(is) * Je)';            imageR(2:2:end,:)=0;     %(uneven pixels in y-range turn to bg)        end        if SGSp.eyes==1;            image(SGSp.posR(2)+1:SGSp.posR(4),SGSp.posR(1)+1:SGSp.posR(3)) = imageR;        end        if SGSp.eyes==2;            image(SGSp.posR(2)+1:SGSp.posR(4),SGSp.posR(1)+1:SGSp.posR(3)) = ...                image(SGSp.posR(2)+1:SGSp.posR(4),SGSp.posR(1)+1:SGSp.posR(3))+ imageR;        end               screen(offscreen(i),'PutImage',image,SGSp.rect);    endend dS = {'displayType', displayType, 'displayProc', displayProc, ...	'offscreen', offscreen, 'frames', SGSp.N, 'depth', 8, ...	'clut_usage', clut_usage, 'clut_bg', clut_bg, 'clut', clut};outstim = SGSstim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);sgs = outstim;
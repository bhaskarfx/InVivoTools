function [outstim] = loadstim(PSstim)PSstim = unloadstim(PSstim);StimWindowGlobals;PSparams = PSstim.PSparams;dfs = struct(getdisplayprefs(PSstim));if dfs.fps<0,      %compute displayprefs info    fps = StimWindowRefresh;    tRes = round( (1/PSparams.tFrequency) * fps);    % screen frames / cycle    frames = repmat(1:tRes,1,PSparams.nCycles); % each frame within a cycle gets unique number, repeated for each cycle    % Special case: animType == 1    if (PSparams.animType == 1) % if a square wave, only 2 frames        fps = tRes;        frames = 2;    end;    oldRect = PSparams.rect;    width=oldRect(3)-oldRect(1); height=oldRect(4)-oldRect(2);    dims = max(width,height); %Picks longest side of image    newrect = [oldRect(1) oldRect(2) oldRect(1)+dims oldRect(2)+dims]; % now a square     if PSparams.windowShape==2|PSparams.windowShape==3, %#ok<OR2> % make newrect large enough to contain tilted oldRect        angle = mod(PSparams.angle,360)/180*pi;        trans = [cos(angle) -sin(angle); sin(angle) cos(angle)];        ctr = [mean(oldRect([1 3])) mean(oldRect([2 4]))];        cRect=(trans*([oldRect([1 2]);oldRect([3 2]);oldRect([3 4]);oldRect([1 4])]-repmat(ctr,4,1))')'+repmat(ctr,4,1);        dimnew = [max(cRect(:,1))-min(cRect(:,1)) max(cRect(:,2))-min(cRect(:,2))];        ID = max(dimnew);        newrect = ([-ID -ID ID ID]/2+repmat(ctr,1,2));    end;    dp={'fps',fps, 'rect',newrect,'frames',frames,PSparams.dispprefs{:} };    PSstim = setdisplayprefs(PSstim,displayprefs(dp));end;% 	% Special case: Bar-type stims% 	if (PSparams.imageType >= 6)%      	% Scale barWidth from cm units to its proportion of the sFrequency%      	PSparams.barWidth = PSparams.barWidth/(PSparams.distance * tan((pi/180)/PSparams.sFrequency));%%     	% Fix color levels to allow for manual setting of bar/backdrop colors%      	PSparams.contrast=1;%      	PSparams.background=.5;%    endtRes = round( (1/PSparams.tFrequency) * StimWindowRefresh);  % screen frames / cycle% all PSstims are color table animations, so let's now create the imageNewStimGlobals; % for NewStimViewingDistance and NewStimPixelsPerCm% Convert argument unitsangle = 2*pi-mod(PSparams.angle,360)/180*pi;	% Correct for overlarge angles, Convert angle to radians% Flip direction (increasing angle progresses *clockwise*)% determine wavelength of grating in pixels per cycle by converting first sFrequency (spatial frequency of gratings% expressed in cycles per degrees of visual angle) into centimeters per cycle by taking its tangent and multiplying by the% distance from screen (cm), then this value of wavelength in cm is converted to pixels per cycle by the conversion factor.% changed to cycles/degree 5/2/2001 SDVwLeng = (NewStimViewingDistance * tan((pi/180)/PSparams.sFrequency)) * NewStimPixelsPerCm;rect = PSparams.rect;heightT = rect(4)-rect(2); widthT = rect(3)-rect(1);%imageDimsTotal = max(heightT,widthT);rect = PSparams.rectimage;height = rect(4)-rect(2); width = rect(3)-rect(1);imageDims = max(height,width);cRect = [PSparams.rect];if (PSparams.windowShape==1), mkClp = 2;     % non-oriented ovalelseif (PSparams.windowShape==0), mkClp = 1; % non-oriented ovalelseif (PSparams.windowShape==2|PSparams.windowShape==3), %#ok<OR2> % clip to grating orientation    mkClp = 3;    ctr = [mean(PSparams.rect([1 3])) mean(PSparams.rect([2 4]))]    effangle= -2*pi+(mod(PSparams.angle,360))/180*pi %-angle    trans = [cos(effangle) -sin(effangle); sin(effangle) cos(effangle)];    cRect=(trans*([PSparams.rect([1 2]);PSparams.rect([3 2]);PSparams.rect([3 4]);PSparams.rect([1 4])]-repmat(ctr,4,1))')'+repmat(ctr,4,1);    dimnew = [max(cRect(:,1))-min(cRect(:,1)) max(cRect(:,2))-min(cRect(:,2))];    imageDims = ceil(max(dimnew));    if (PSparams.windowShape==3), % make oval rect        xx=linspace(-width/2,width/2,50);        yyp=(height/width) * sqrt(width*width/4-xx.*xx); yyn=-yyp(end:-1:1);        cRect=((trans*[xx' yyp' ; xx(end:-1:1)' yyn']')'+repmat(ctr,50*2,1));        figure(5); plot(cRect(:,1),cRect(:,2)); axis equal;    end;end;cRect=(cRect); % make sure contains only pixel values% Make theImageif(PSparams.imageType==0)    %field    theImage = 255*ones(imageDims,imageDims);else    % Preallocate space for the big variables    theImage = zeros(imageDims,imageDims);    ramp = zeros(imageDims);    % Make an array steadily increasing across imageDims pixels    pixelIncrement = 255/wLeng;						% Find proper pixel-to-pixel increment value    rampEndValue = imageDims * pixelIncrement;	    % Find the max value of the ramp reached by the last pixel in the array    ramp = 0:pixelIncrement:rampEndValue;			% Make a ramp from 0 to that max value using the increment value as the step size    ramp(imageDims+1:length(ramp))=[]; 				% Clip any extra elements    [x,y]=meshgrid(ramp,ramp);						%Create vertical- and horizontal-ramp matrices    theImage=( x.*(sin(angle)) + y.*(cos(angle)));    % Do weighted sum of component matrices to handle range of angles    theImage=theImage-254*floor(theImage/254)+1; 	% Squish the range of indices to lie in 8-bit range (i.e. valid clut values)    theImage = uint8(theImage);endShowStimScreenoffscreen = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 widthT heightT]);theImageR=theImage;theImageL=theImage;theImageL(1:2:end,:)=0;theImageR(2:2:end,:)=0;backdrop=zeros(heightT,widthT);backdrop(PSparams.posR(2)+1:PSparams.posR(2)+height, PSparams.posR(1)+1:PSparams.posR(1)+width)=theImageR(1:height,1:width);TotalImageR=backdrop;backdrop=zeros(heightT,widthT);backdrop(PSparams.posL(2)+1:PSparams.posL(2)+height, PSparams.posL(1)+1:PSparams.posL(1)+width)=theImageL(1:height,1:width);TotalImageL=backdrop;TotalImageLR=TotalImageL+TotalImageR;switch PSparams.eyes    case 0        screen(offscreen,'PutImage',TotalImageL,[0 0 widthT heightT]);    case 1        screen(offscreen,'PutImage',TotalImageR,[0 0 widthT heightT]);    case 2        screen(offscreen,'PutImage',TotalImageLR,[0 0 widthT heightT]);end% now to make the color tablesPSparamswhos%keyboardoffstate = PSparams.background;maxOffset	= min ( (abs(1-offstate)), abs(offstate) );dark      = offstate - maxOffset*PSparams.contrast; % luminance of darkest shadelight     = offstate + maxOffset*PSparams.contrast; % luminance of brightest shade% Determine flicker range for stationary gratingsswitch PSparams.flickerType    case 0 % light -> background -> light...        hoffset=(light+offstate)/2; hamp=(light-offstate)/2;        loffset=(offstate+dark)/2;  lamp=-(offstate-dark)/2;    case 1 % dark -> background -> dark...        hoffset=(dark+offstate)/2; hamp=(dark-offstate)/2;        loffset=(offstate+light)/2;  lamp=-(offstate-light)/2;    case 2 % counterphase...        hoffset=(light+dark)/2; hamp=(light-dark)/2;        loffset=(light+dark)/2; lamp=-(light-dark)/2;end% Convert from proportion values (0.0-1.0) to clut values (0-255)dark=dark*255;light=light*255;% background = offstate*255;backdrop = PSparams.backdrop*255;barColor = PSparams.barColor*255;barwidth = PSparams.barWidth;switch PSparams.imageType    %Field��Single luminance across field    case 0        ourClut = light*ones(1,255);        % Simple Periodic Stimuli        %  'spaceCycles' variable determines number of periods repeated in field        % Square��Field split into light and dark halves    case 1        amp = .5*(light-dark);        center = .5*(light+dark);        ourClut = [ones(1,ceil(255/2)) zeros(1,floor(255/2))];        %ourClut = round(.5+.5*sin(2*pi*(1:255)/(255)));        % set middle of clut to half value:        ourClut(ceil(length(ourClut)/2))=(max(ourClut)+min(ourClut))/2;        filtVec = ones(1,PSparams.nSmoothPixels+1);	% simple box filter        ourClut = CONV(filtVec,ourClut); % smooothed square clut        %XR: Following is wrong, should delete maximun points instead of taking 1st 255 points        ourClut = ourClut(1:255)/max(ourClut(1:255));        ourClut = (ourClut*2-1)*amp+center;        % Sine��Smoothly varying shades    case 2        amp = .5*(light-dark);        center = .5*(light+dark);        ourClut = round( center + amp*sin( 2*pi*(0:254)/255 ) );        % Triangle��Linear light->dark->light transition    case 3        ourClut = 2*linspace(dark,light,255) -2*255*floor(linspace(dark,light,255)/255);        ourClut = ourClut-2*(ourClut-255).*floor(ourClut./(255)); % will make the triangle shape        ourClut = 1+ourClut/max(ourClut)*254; % normalize for a1 extra-good full delicious spectrum        % Lightsaw��Linear light->dark transition    case 4        ourClut = linspace(light/255,dark/255,255);        filtVec = ones(1,PSparams.nSmoothPixels+1);	% simple box filter        ourClut = CONV(filtVec,ourClut); % smooothed square clut        ourClut = ourClut(1:255)/max(ourClut(1:255));        ourClut = ourClut*255;        % Darksaw��Linear dark->light transition    case 5        ourClut = linspace(dark/255,light/255,255);        filtVec = ones(1,PSparams.nSmoothPixels+1);	% simple box filter        ourClut = CONV(filtVec,ourClut); % smooothed square clut        ourClut = ourClut(1:255)/max(ourClut(1:255));        ourClut = ourClut*255;        %%% Bar-oriented stimuli        % Bar��Bars of <barwidth> width and <barColor> luminance    case 6        % Make basic bars clut        barwidth = round(barwidth*255);        ourClut = backdrop*ones(1,255);        ourClut(1:barwidth) = barColor*ones(1,barwidth);        % Anti-alias the bar edges        filtVec = ones(1,PSparams.nSmoothPixels+1);	% simple box filter        ourClut = CONV(filtVec,[repmat(ourClut(1),1,PSparams.nSmoothPixels+1) ... % correct for edges            ourClut repmat(ourClut(end),1,PSparams.nSmoothPixels+1)]); % smooothed square clut        theInds = [ 1 : 255 ] + fix((length(ourClut)-255)/2);        ourClut = ourClut(theInds)/max(ourClut(theInds));        ourClut = ourClut*255;        % Edge��Like Lightsaw but with bars determining width of saw    case 7        barwidth = round(barwidth*255);        ourClut = backdrop*ones(1,255);        ourClut(1:barwidth) = linspace(barColor,backdrop,barwidth);        % Bump��Bars with internal smooth dark->light->dark transitions    case 8        barwidth = round(barwidth*255);        ourClut = backdrop*ones(1,255);        ourClut(1:barwidth) = barColor*sin(pi*(0:barwidth-1)/barwidth);endtRes = floor(tRes); % round tRes down to be safe% flashing/blinkingswitch PSparams.animType    % Square    case 1		        % if using square-wave animation for counterphase dispaly        if PSparams.flickerType == 2            highVal = zeros(1,tRes)+hoffset-hamp;            lowVal  = zeros(1,tRes)+loffset-lamp;            % zmr: following adjustment made so that the fixed on-duration            % fliker is exactly half the time on for every temporal cycle.            highVal(1:round(tRes/2)) = hamp+hoffset;            lowVal(1:round(tRes/2)) = lamp+loffset;            %rubu = 'counterphase';            % for all other flicker types        else            highVal = hamp*2*(1-floor((0:tRes-1)/tRes*2))+hoffset-hamp;            lowVal  = lamp*2*(1-floor((0:tRes-1)/tRes*2))+loffset-lamp;            %rubu = 'other';        end        % Sine    case 2        highVal = hamp*(sin(2*pi*(1:tRes)/tRes))+hoffset;        lowVal  = lamp*(sin(2*pi*(1:tRes)/tRes))+loffset;        % Ramp    case 3        highVal = 2*hamp*((1:tRes)/tRes)+hoffset-hamp;        lowVal  = 2*lamp*((1:tRes)/tRes)+loffset-lamp;        % Drifting    case 4        highVal=ones(1,tRes)*hoffset+hamp;        lowVal =ones(1,tRes)*loffset+lamp;        %fixed on-dur square	XR implement on 4/6/2000    case 5        highVal = zeros(1,tRes)+hoffset-hamp;        lowVal  = zeros(1,tRes)+loffset-lamp;        highVal(1:PSparams.fixedDur) = hamp+hoffset;        lowVal (1:PSparams.fixedDur) = lamp+loffset;        % Standing, no change    otherwise        highVal=ones(1,tRes)*hoffset+hamp;        lowVal =ones(1,tRes)*loffset+lamp;endboost = 255*lowVal;gain  = highVal-lowVal;len   = length(ourClut);isMoving = (PSparams.animType == 4); % By default, grating is stationary, if drifting, set to true (see case 4 below)% get the phase shift value in radiansphs = mod(PSparams.sPhaseShift,2*pi); % Correct for overlarge anglesif (isMoving) & (phs == 0) 	%#ok<AND2> % for moving grating w/o any phase shift    for i = 0:tRes-1        if i == 0            ourClutIndex = 1:len;        else            ourClutIndex = [ceil(len*i/tRes):len 1:ceil(len*i/tRes)-1];        end        clutEntries(i+1,:) = ourClut(ourClutIndex)*gain(i+1)+boost(i+1);    endelseif (isMoving) & (phs ~= 0)	%#ok<AND2> % for moving grating with a phase shift offset at start    for i = 0:tRes-1        if i == 0            shftd = [ceil((len*phs) / (2*pi)):len 1:ceil((len*phs) / (2*pi))-1];            ourClutIndex = shftd;        else            indx = [ceil(len*i/tRes):len 1:ceil(len*i/tRes)-1];            ourClutIndex = shftd(indx);        end        clutEntries(i+1,:) = ourClut(ourClutIndex)*gain(i+1)+boost(i+1);    end    % zmr: this condition checks whether a spatial phase shift is required    % it adjusts the clutEntries lookup table so that the apropriate phase shift effect is achievedelseif phs ~= 0	% for static grating with a spatial phase shift of phs radians    ourClutIndex = [ceil((len*phs) / (2*pi)):len 1:ceil((len*phs) / (2*pi))-1];    gain	= meshgrid(gain,1:len)';    boost	= meshgrid(boost,1:len)';    clutEntries = meshgrid(ourClut(ourClutIndex),1:tRes) .* gain + boost;    %rubu = 'two'else 			% for static grating without a spatial phase shift    ourClut=meshgrid(ourClut,1:tRes);    gain   =meshgrid(gain,1:len)';    boost  =meshgrid(boost,1:len)';    clutEntries = ourClut.*gain+boost;    %rubu = 'three'end% assemble all the clutsoffClut = backdrop*ones(256,3);  % offClut = ones(256,1)*backdrop; when backdrop is [1 3] vectortheCluts = zeros(256,tRes);theCluts(1,:)=backdrop*ones(1,tRes);	% backgroundfor i = 1:tRes    theCluts(2:256,i) = clutEntries(i,:)'; % b/wendclut = cell(size(theCluts,2),1);clut_bg = repmat(PSparams.chromlow,256,1)+repmat(PSparams.chromhigh-PSparams.chromlow,256,1).*offClut/255;%if PSparams.chrom == 0		% i.e. b/w%	clut_bg = offClut;%elseif PSparams.chrom == 1	% i.e. r/b%	clut_bg = offClut .* (ones(256,1)*[1 0 1]);%end;clut_usage = ones(size(clut_bg));for i=1:size(theCluts,2),    clut{i} = repmat(PSparams.chromlow,256,1)+...        repmat(PSparams.chromhigh-PSparams.chromlow,256,1).*theCluts(:,i*[1 1 1])/255;    % if an achromatic (b/w) periodic stimulus required    %if PSparams.chrom == 0    %	clut{i} = theCluts(:,i)*[1 1 1];    % if a chromatic (r/b) periodic stimulus required    %elseif PSparams.chrom == 1    %	clut{i} = [backdrop*[1 0 1]; theCluts(2:256,i)*[1 0 -1] + ones(255,1)*[0 0 255]];    %endend;dS = { 'displayType', 'CLUTanim', 'displayProc', 'standard', ...    'offscreen', offscreen, 'frames', size(theCluts,2), ...    'clut_usage', clut_usage, 'depth', 8, ...    'clut_bg', clut_bg, 'clut', clut, 'clipRect', cRect , ...    'makeClip', mkClp,'userfield',[] };outstim = PSstim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);
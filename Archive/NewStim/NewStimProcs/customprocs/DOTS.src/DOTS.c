/* DOTS.cModifications:  2004-01-14 Steve Van Hooser, Brandeis University    Added a CopyDots command.COPYRIGHT:  Copyright David Brainard and the University of California, 1992, 1993.  This file may be distributed freely as long as this notice accompanies  it and any changes are noted in the source.  It is distributed as is,  without any warranty implied or provided.  We accept no liability for  any damage or loss resulting from the use of this software.PURPOSE:  MEX routine to drive random dot psychophysics.  Works as an adjunct  to SCREEN.  I kept it out of SCREEN for modularity.    This file is mainly a dispatch module.  The first argument determines what  gets done.HISTORY:	4/10/94		dhb		Wrote it.	2/10/96		dhb,mns	Converted to drive Shadlen dot routines.	3/28/96   mns incorporated the VBL routine and the GetSetPixXor routine	9/11/96   jdr,mns added size  sXorDots	11/12/97 	jig, re-wrote for MATLAB 5.0 and CODEWARRIOR IDE 2.0	7/6/98		jig, removed InstallVBL (already in SCREEN 'OpenWindow')*//* ** Procedure Declarations 	** */void Close(void);/* ** Data Types ** */#define MAX_CMD_NAME_LENGTH 30typedef struct {	char command[MAX_CMD_NAME_LENGTH];	void (*routine) ();} dispatch_table_entry;// REGISTER NEW COMMANDS HEREextern void XorDots(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);extern void CopyDots(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);static dispatch_table_entry dispatch_table[] = {	{"XorDots",  (void *) (&XorDots) },	{"CopyDots", (void *) (&CopyDots)} };	// number of registered commands#define NUMBER_COMMANDS (sizeof(dispatch_table)/sizeof(dispatch_table_entry))/** ROUTINE: mexFunction**	This is the entry point to the mex function. The first time called, it initializes*	quickDraw, etc.*	*	Arguments:*		1. the current window pointer*		2. string name of the function to be called (XorDots, ...)*		3. dot position matrix*		4. <Optional> [x y] offsets*		5. <Optional> boolean, wait for VBL*		6. <Optional> boolean, send "went" flag*/void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]){	static int firstTime = TRUE;	static WindowPtr theWindow;	int i;	unsigned int buflen;	char command[MAX_CMD_NAME_LENGTH];	PsychTable *psychTable = GetPsychTable();		// Check arguments	if(nrhs < 2) 		PrintfExit("DOTS: requires at least two arguments");		// First argument should be the window pointer	if(IsDefaultMat(prhs[0]) || mxIsNumeric(prhs[0]))		psychTable->windowPtrArgument = prhs[0];	else {		psychTable->windowPtrArgument = NULL;		PrintfExit("DOTS: first argument should be a valid window");	}		// Second argument is the function name	if(!mxIsChar(prhs[1])) 		PrintfExit("DOTS: second argument should be a text variable");	 	// find out how long the input string array is	if((buflen = mxGetM(prhs[1]) * mxGetN(prhs[1]) + 1) > MAX_CMD_NAME_LENGTH)		PrintfExit("DOTS: command name is too long for allocated buffer");		// copy the string data to the buffer	if(mxGetString(prhs[1], command, buflen))		PrintfExit("DOTS: could not convert command name string data");			// Initialize on first pass through	if (firstTime) {			// Initialize the quickDraw globals		InitMEX();		// Deal with exit.  This should take out the VBL task.		AtExitToShell(Close);				// Reset flag		firstTime = FALSE;	}		// Dispatch out to the world.	for (i=0; i<NUMBER_COMMANDS; i++) {		if (!strcmp(command, dispatch_table[i].command)) {			(*(dispatch_table[i].routine)) (nlhs, plhs, nrhs-2, &(prhs[2]));			break;		}	}		// Make sure we found the command	if(i == NUMBER_COMMANDS)		mexWarnMsgTxt("DOTS: no command of passed name available");	// Tidy up	psychTable->windowPtrArgument = NULL;}void Close(void){	PsychTable *psychTable = GetPsychTable();		RemoveVBL(GetDeviceFromWindowPtrOrScreenNumberMat(psychTable->windowPtrArgument));}
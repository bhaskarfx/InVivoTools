function [outstim] = loadstimPTB3(stim)%lammestim/loadstim%%% everything is setup by loadstim for movement of both figure and ground,% but stimulus' typenumber determinus which parts actually move% this takes more memory, but it was by far the easiest way to ensure% that the onset stimuli are identical for all cases.%% if gnddirection=NaN, figdirection is used for gndirection%%% lamme modulation index: (4+5)/(3+6)%% 2012, Alexander Heimel%StimWindowGlobals;NewStimGlobals;stim = unloadstim(stim);  % unload old version before loadingparams = stim.params;% fill in NaN parametersif isnan(params.gndspeed)    params.gndspeed = params.figspeed;endif isnan(params.gnddirection)    params.gnddirection = params.figdirection;endif isnan(params.figtextureparams(4))    params.figtextureparams(4) = params.figdirection;endif isnan(params.gndtextureparams)    params.gndtextureparams = params.figtextureparams;    params.gndtextureparams(4) = params.gnddirection;endif isnan(params.figorientation)    params.figorientation = params.figdirection;endif isnan(params.movement_duration)    if params.movement_onset>=0        params.movement_duration = params.duration - params.movement_onset;    else        params.movement_duration = 0;    endendif params.reverse_figdirection    params.figdirection = mod(params.figdirection + 180,360);endif params.reverse_gnddirection    params.gnddirection = mod(params.gnddirection + 180,360);end% set texture or gratingif isfield(params,'imageType') && ~isempty(params.imageType) && params.imageType~=9    usegrating = true;else     usegrating = false;endwidth  = params.rect(3) - params.rect(1);height = params.rect(4) - params.rect(2);% set initial random staterand('state',params.randState); %#ok<RAND>% set BG, figure and ground colorsfigbg_rgb = params.figbg;figtxt_rgb = figbg_rgb * (1+ params.figcontrast );gndbg_rgb = params.gndbg;gndtxt_rgb = gndbg_rgb * (1+params.gndcontrast);clut_bg = repmat(params.BG,256,1);clut_usage = [];clut = repmat( (0:255)',1,3);% check MovieParams2MTIds_userfield.Movie_globalalphas = [];ds_userfield.Movie_sourcerects = [];dp = getdisplayprefs(stim.stimulus);dps = struct(dp);% params.framerate contains the stimulus framerate% this is lower than monitor rate to reduce memory load% but with PTB3 it is no longer necessary and thus no longer used.n_frames = ceil(params.duration * StimWindowRefresh);n_still_frames_before_movement = round(params.movement_onset * StimWindowRefresh);n_still_frames_without_figure = round( min(params.figure_onset, params.movement_onset) * StimWindowRefresh);n_movement_frames = round(params.movement_duration * StimWindowRefresh);n_movement_frames_without_figure = round(max(0,(params.figure_onset - params.movement_onset)) * StimWindowRefresh);n_still_frames_after_movement = n_frames - n_still_frames_before_movement - n_movement_frames;ShowStimScreen;unit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / StimWindowRefresh;% set ground stimulusgnddestwidth = width * abs(sin(params.gnddirection*pi/180)) + height * abs(cos(params.gnddirection*pi/180));gnddestheight = height * abs(sin(params.gnddirection*pi/180)) + width * abs(cos(params.gnddirection*pi/180));gndmotion_per_frame = unit_motion_per_frame * params.gndspeed;  % in pixelsgndtotalmovingdistance = abs(gndmotion_per_frame) * n_movement_frames;gndrectwidth = gnddestwidth + gndtotalmovingdistance*2; % factor 2 is to use same rect for both forward and reverse motiongndrectheight = gnddestheight; gnddestrect = [-gnddestwidth/2 -gnddestheight/2 gnddestwidth/2 gnddestheight/2] + [width/2 height/2 width/2 height/2];% make large offscreen with ground stimulusif usegrating    offscreen_gnd =  makegrating( params.imageType,params.gndtextureparams,...        gndrectwidth,(gndrectwidth+1)/2);else    offscreen_gnd = Screen('MakeTexture',StimWindow,zeros(gndrectheight+1,gndrectwidth+1,'uint8'));    fillwithtexture(offscreen_gnd, gndtxt_rgb, gndbg_rgb,  params.gndtextureparams)end% set figure stimulusfigwidth_pixels = NewStimViewingDistance * 2 *tan(params.figsize(1) /2 * pi/180) * pixels_per_cm;figheight_pixels = NewStimViewingDistance * 2 *tan(params.figsize(2) /2 * pi/180) * pixels_per_cm;figdestwidth = figwidth_pixels * abs(sin(params.figdirection*pi/180)) + figheight_pixels * abs(cos(params.figdirection*pi/180));figdestheight = figheight_pixels * abs(sin(params.figdirection*pi/180)) + figwidth_pixels * abs(cos(params.figdirection*pi/180));figmotion_per_frame = unit_motion_per_frame * params.figspeed;  % in pixelsfigtotalmovingdistance = abs(figmotion_per_frame) *  (n_movement_frames-n_movement_frames_without_figure);figrectwidth = figdestwidth + figtotalmovingdistance*2; % factor 2 is to use same rect for both forward and reverse motionfigrectheight = figdestheight; figdestrect = [-figdestwidth/2 -figdestheight/2 figdestwidth/2 figdestheight/2] + ...    [params.figcenter(1) params.figcenter(2) params.figcenter(1) params.figcenter(2)];% make large offscreen with figure stimulusif usegrating    dx = params.figcenter(1)-(width+1)/2;    dy = params.figcenter(2)-(height+1)/2;    zerophasepos = (figrectwidth+1)/2    %if dx^2+dy^2>0    %   zerophasepos = zerophasepos- sqrt(dx^2+dy^2)*sin(params.figdirection*pi/180- atan(dy/dx));        d=[dx;dy];    b=[sin(params.figdirection/180*pi);cos(params.figdirection/180*pi)];        zerophasepos = zerophasepos + d'*b;    % end        offscreen_fig =  makegrating( params.imageType,params.figtextureparams,...        figrectwidth,zerophasepos,0);    disp('LAMMESTIM/LOADSTIMPTB3: STILL TO IMPLEMENT CIRCULAR SHAPE');else    offscreen_fig = Screen('MakeTexture',StimWindow,zeros(figrectheight+1,figrectwidth+1,'uint8'));    % set drawing region, dependent on stimulus shape    tempfigtext = params.figtextureparams;    tempfigtext(4) = tempfigtext(4) - params.figorientation;    fillwithtexture(offscreen_fig, figtxt_rgb, figbg_rgb,  tempfigtext)endgndpos = [abs(gndmotion_per_frame)*n_movement_frames 0]; figpos = [abs(gndmotion_per_frame)*(n_movement_frames-n_movement_frames_without_figure) 0]  ;% Make frames% texture 1 is background% texture 2 is figuretexgnd = 1;texfig = 2;% make still frame without figurefor f = 1:n_still_frames_without_figure    ds_userfield.Movie_textures{f} = texgnd;    ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;end% make still frames with ground and figurefor f = (n_still_frames_without_figure+1) : n_still_frames_before_movement    ds_userfield.Movie_textures{f} = [texgnd texfig];        ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;        ds_userfield.Movie_sourcerects(:,f,texfig) = [figpos figpos+[figdestwidth figdestheight]];    ds_userfield.Movie_destrects(:,f,texfig) = figdestrect;    ds_userfield.Movie_globalalphas(1,f,texfig) = 1;    ds_userfield.Movie_angles(1,f,texfig) = params.figdirection+90;endfor f=(n_still_frames_before_movement+1):(n_movement_frames+n_still_frames_before_movement+1) % moving frames    % ground movement    if params.ground_moves        gndpos = gndpos + [gndmotion_per_frame 0];    end        % copy ground     ds_userfield.Movie_textures{f} = [texgnd texfig];    ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;    if f-n_still_frames_before_movement >n_movement_frames_without_figure        % figure movement        if params.figure_moves            if params.fixed_aperture                figpos = figpos + [gndmotion_per_frame 0];            else                disp('LAMMESTIM/LOADSTIMPTB3: MOVING POSITION NOT IMPLEMENTED YET');                % then entire figure moves, and thus the figdrawingregion                %figdrawingregion = figdrawingregion + repmat( figmotion_per_frame,size(figdrawingregion,1),1);                %figpos = figpos + repmat( figmotion_per_frame,size(figpos,1),1);            end        end                % copy figure to offscreen        ds_userfield.Movie_sourcerects(:,f,texfig) = [figpos figpos+[figdestwidth figdestheight]];        ds_userfield.Movie_destrects(:,f,texfig) = figdestrect;        ds_userfield.Movie_globalalphas(1,f,texfig) = 1;        ds_userfield.Movie_angles(1,f,texfig) = params.figdirection+90;    endend;for f=(n_movement_frames+n_still_frames_before_movement+2):(n_movement_frames+n_still_frames_before_movement+1)  +n_still_frames_after_movement% moving frames    ds_userfield.Movie_textures{f} = [texgnd texfig];    ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;    ds_userfield.Movie_sourcerects(:,f,texfig) = [figpos figpos+[figdestwidth figdestheight]];    ds_userfield.Movie_destrects(:,f,texfig) = figdestrect;    ds_userfield.Movie_globalalphas(1,f,texfig) = 1;    ds_userfield.Movie_angles(1,f,texfig) = params.figdirection+90;end% now translate into movie with refreshrate set by monitor% set framerate if there is open stimscreenif ~isempty(StimWindowRefresh)    dps.fps = StimWindowRefresh; % monitor framerateelse    error('LAMMESTIM/LOADSTIM: StimWindowRefresh is empty');endn_frames = size(ds_userfield.Movie_sourcerects,2);dps.frames = (1:n_frames);if isfield(dps,'defaults')    dps = rmfield(dps,'defaults');enddisp('LAMMESTIM/LOADSTIMPTB3: Working on clipping outside surround');if 0    PSstim = periodicstim('default');    PSparams = getparameters(PSstim);    PSparams.rect = StimWindowRect;    PSparams.size = 20;    PSparams.windowShape = 1;    PSparams.nCycles = n_frames/StimWindowRefresh*PSparams.tFrequency;    PSstim = periodicstim(PSparams);    if PSparams.windowShape>-1,        [clip_image,clip_dest_rect,ds_clipuserfield] = makeclippingrgn(PSstim);        clip_tex = Screen('MakeTexture',StimWindow,clip_image);        for i=1:n_frames, ds_clipuserfield.Movie_textures{i} = 1; end;                dS_clip = { 'displayType', 'Movie', 'displayProc', 'standard', ...            'offscreen', clip_tex, 'frames', n_frames, 'clut_usage', clut_usage, 'depth', 8, ...            'clut_bg', clut_bg, 'clut', clut, 'clipRect', [] , 'makeClip', 0,'userfield',ds_clipuserfield };        DS_clip = displaystruct(dS_clip);        dp_clip = {'fps',StimWindowRefresh,'rect',clip_dest_rect,'frames',1:n_frames,PSparams.dispprefs{:} };        DP_clip = displayprefs(dp_clip);        moviefields_clip = MovieParams2MTI(DS_clip,DP_clip);        ds_userfield = MovieParamsCat(ds_userfield,moviefields_clip);        % offscreen        % MTI.ds.offscreen(textures) should also contain merged textures        disp('LAMMESTIM/LOADSTIMPTB3: Alexander working here');    end;else    clip_tex = [];endstim = setdisplayprefs(stim,displayprefs(struct2vararg(dps)));dS = {'displayType', 'Movie', 'displayProc', 'standard', ...    'offscreen', [offscreen_gnd,offscreen_fig,clip_tex], 'frames', n_frames, 'depth', 8, ...    'clut_usage', clut_usage, 'clut_bg', clut_bg, 'clut', clut, ...    'clipRect', [] , 'makeClip', 0,'userfield',ds_userfield };outstim = stim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);disp('LAMMESTIM/LOADSTIMPTB3: Stimulus loaded');returnfunction offscreen =  makegrating( imageType, txtparams, width_offscreen,zerophasepos,phaseshift )% phaseshift in rad% zerophasepos in pixelsif nargin<4    zerophasepos = (width_offscreen)+1/2; endif nargin<5    phaseshift = 0;end% zerophasepos = round(zerophasepos);NewStimGlobalsStimWindowGlobalssFrequency = 1/(2*txtparams(1)); % using barwidth (deg) as half cycledistance = NewStimViewingDistance;wLeng = (distance * tan((pi/180))/sFrequency) * pixels_per_cm;  % units: pixels per cyclepixelIncrement = 2*pi/wLeng; % radzerophasepos_pi = zerophasepos * pixelIncrement;phase = mod( phaseshift + ( (0-zerophasepos_pi):pixelIncrement:((width_offscreen-1)*pixelIncrement-zerophasepos_pi)) , 2*pi);  % 1-D grating phase as a function of spacedisp(['Phase start: ' num2str(phase(1)) ' end: ' num2str(phase(end))]);switch imageType,	case 0,  % field		grating = 1;	case 1, % square wave		grating = -1+2*double(cos(phase)>0);	case 2, % sine wave		grating = cos(phase);	case 3, % triangle		grating = -1+2*(abs(phase - pi)/pi);	case 4, % light saw		grating = -1+2*(2*pi-phase)/(2*pi);	case 5, % dark saw		grating = -1+2*phase/(2*pi);	case 6, % bars		grating = double(phase<(ps.PSparams.barWidth*2*pi))*2*(ps.PSparams.barColor-0.5);	case 7, % edge, like lightsaw but with bars determining width of saw		phasemod = phase;		phasemod(phase<ps.PSparams.barWidth*2*pi) = 0;		nonzerovalues = find(phase>=ps.PSparams.barWidth*2*pi);		phasemod(nonzerovalues) = 1-rescale(phase(nonzerovalues),[min(phase(nonzerovalues)) max(phase(nonzerovalues))],[0 1]);		grating = phasemod;	case 8, % bump (bars with internal smooth dark->light->dark transitions (sinusoidal)		phasemod = phase;		phasemod(phase>=ps.PSparams.barWidth*2*pi) = 0;		phasemod = sin(-pi/2+2*pi*phasemod./max(phasemod));		phasemod(phase>=ps.PSparams.barWidth*2*pi) = 0;		grating = phasemod;    case 9, % texture            disp('LAMMESTIM/LOADSTIMPTB3: imageType texture should be handled elsewhere');	otherwise,		error(['Unknown image type imageType']);end;colors.low_rgb = [0 0 0];colors.high_rgb = [255 255 255];img_colorized = cat(3,...    rescale(grating,[-1 1],[colors.low_rgb(1) colors.high_rgb(1)]),...	rescale(grating,[-1 1],[colors.low_rgb(2) colors.high_rgb(2)]),...	rescale(grating,[-1 1],[colors.low_rgb(3) colors.high_rgb(3)]));offscreen = Screen('MakeTexture',StimWindow,img_colorized);function fillwithtexture(offscreen, txtcolor, bgcolor,textureparams)%NewStimGlobalsrect = Screen(offscreen,'Rect');rectwidth = rect(3)-rect(1);rectheight = rect(4)-rect(2);% compute texture elementstxtwidth = textureparams(1);txtlength = textureparams(2);txtdensity = textureparams(3);txtangle = textureparams(4);% compute rotation matrix%angle = (-txtangle) * pi /180 + pi/2; % convert to degreesangle = pi/2; % convert to degreesrotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];txtwidth_pixels = NewStimViewingDistance * 2*tan(txtwidth/2 *pi/180) * pixels_per_cm;txtlength_pixels = NewStimViewingDistance * 2*tan( txtlength/2 *pi/180) * pixels_per_cm;%txtextend = abs(rotation * [txtwidth_pixels txtlength_pixels]' )';txtarea = 2*txtlength_pixels*2*txtwidth_pixels;number_of_txts_to_fill_rect = rectheight * rectwidth / txtarea;n_txts = ceil(txtdensity * number_of_txts_to_fill_rect);%rf_clearance_radius_pixels = NewStimViewingDistance * 2* tan( params.rf_clearance_radius/2 *pi/180) * pixels_per_cm;txtbasepoints =...    [ -txtwidth_pixels -txtlength_pixels; ...    -txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels -txtlength_pixels ];txtbasepoints = (rotation * txtbasepoints')';txtpoints = cell(n_txts,1);for i = 1:n_txts    center_clear = 0;    while ~center_clear        %gndcenter = [gndrectleft+gndrectwidth*rand(1) gndrecttop+gndrectheight*rand(1)];%        txtcenter = [rectwidth*rand(1) rectheight*rand(1)]; % genereate random position        % still need to add full extend to this        txtpoints{i} = txtbasepoints + repmat(round(txtcenter),4,1);        center_clear = 1;        %		for j=1:4        %			if norm(txtpoints{i}(j,:)-params.figcenter) < rf_clearance_radius_pixels        %				center_clear = 0;        %				break;        %			end        %		end    endend% set background colorScreen(offscreen,'FillRect',bgcolor);  % becomes different when figure shape is different% draw texture stimulifor i=1:n_txts    Screen(offscreen,'FillPoly',txtcolor,txtpoints{i});endfunction [new1,new2] = cliprects(rec1,rec2,bound1)%makes rec1 stay within bound1 and clips rec1 and rec2 simulteanouslynew1 = rec1;new2 = rec2;if rec1(1)<bound1(1)    new1(1) = bound1(1);    new2(1) = new2(1) - (rec1(1)-bound1(1)) ;endif rec1(2)<bound1(2)    new1(2) = 0;    new2(2) = new2(2) - (rec1(2)-bound1(2));endif rec1(3)>bound1(3)    new1(3) = bound1(3);    new2(3) = new2(3) - (rec1(3)-bound1(3)) ;endif rec1(4)>bound1(4)    new1(4) = bound1(4);    new2(4) = new2(4) - (rec1(4)-bound1(4)) ;end
function [outstim] = loadstimPTB3(stim)%lammestim/loadstim%%% everything is setup by loadstim for movement of both figure and ground,% but stimulus' typenumber determinus which parts actually move% this takes more memory, but it was by far the easiest way to ensure% that the onset stimuli are identical for all cases.%% if gnddirection=NaN, figdirection is used for gndirection%%% lamme modulation index: (4+5)/(3+6)%% 2012, Alexander Heimel%StimWindowGlobals;NewStimGlobals;stim = unloadstim(stim);  % unload old version before loadingparams = stim.params;if isnan(params.gndspeed)    params.gndspeed = params.figspeed;endif isnan(params.gnddirection)    params.gnddirection = params.figdirection;endif isnan(params.figtextureparams(4))    params.figtextureparams(4) = params.figdirection;endif isnan(params.gndtextureparams)    params.gndtextureparams = params.figtextureparams;endif isnan(params.figorientation)    params.figorientation = params.figdirection;endif isnan(params.movement_duration)    if params.movement_onset>=0        params.movement_duration = params.duration - params.movement_onset;    else        params.movement_duration = 0;    endendif params.reverse_figdirection    params.figdirection = params.figdirection + 180;endif params.reverse_gnddirection    params.gnddirection = params.gnddirection + 180;endwidth  = params.rect(3) - params.rect(1);height = params.rect(4) - params.rect(2);% set initial random staterand('state',params.randState); %#ok<RAND>% set BG, figure and ground colors%max_intensity_color = [255 255 255];figbg_rgb = params.figbg;figtxt_rgb = figbg_rgb * (1+ params.figcontrast );gndbg_rgb = params.gndbg;gndtxt_rgb = gndbg_rgb * (1+params.gndcontrast);clut_bg = repmat(params.BG,256,1);clut_usage = [];%[ ones(1,8) zeros(1,255-8) ]';% transpt_clrind  = 0; %    000, not used as color by itself% figtxt_clrind = 7; % 111% figbg_clrind = 3; % 011% gndtxt_clrind  = 2; % 010% gndbg_clrind  = 1; % 001% with srcCopy as copy mode this, makes it possible to give the figure any% possible shape, where on the figure offscreen the background gets the% transparent colorclut = repmat( (0:255)',1,3);%repmat(params.BG,256,1);%clut(figtxt_clrind+1,:) = figtxt_rgb;%clut(figbg_clrind+1,:) = figbg_rgb;%clut(gndtxt_clrind+1,:) = gndtxt_rgb;%clut(gndbg_clrind+1,:) = gndbg_rgb;dp = getdisplayprefs(stim.stimulus);dps = struct(dp);% params.framerate contains the stimulus framerate% this is lower than monitor rate to reduce memory loadn_frames = ceil(params.duration * params.framerate);n_still_frames_before_movement = round(params.movement_onset * params.framerate);n_still_frames_without_figure = round( min(params.figure_onset, params.movement_onset) * params.framerate);n_movement_frames = round(params.movement_duration * params.framerate);n_movement_frames_without_figure = round(max(0,(params.figure_onset - params.movement_onset)) * params.framerate);n_still_frames_after_movement = n_frames - n_still_frames_before_movement - n_movement_frames;ShowStimScreen;% set ground stimulus% compute moving direction rotation matrixangle = (-params.gnddirection+270) * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute motion vectorunit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / params.framerate;unit_motion_per_frame = -(rotation * [unit_motion_per_frame; 0])'; % in pixels, minus is to match periodicstimgndmotion_per_frame = unit_motion_per_frame * params.gndspeed;  % in pixelsgndtotalmovingdistance = gndmotion_per_frame * n_movement_frames;gndrectwidth = round( params.rect(3) - params.rect(1)+ abs(gndtotalmovingdistance(1))*2); % factor 2 is to use same rect for both forward and reverse motiongndrectheight = round(params.rect(4) - params.rect(2) +abs(gndtotalmovingdistance(2))*2); % factor 2 is to use same rect for both forward and reverse motion% make large offscreen with ground stimulus%offscreen_gnd = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 gndrectwidth gndrectheight]);offscreen_gnd = Screen('MakeTexture',StimWindow,zeros(gndrectheight+1,gndrectwidth+1,'uint8'));fillwithtexture(offscreen_gnd, gndtxt_rgb, gndbg_rgb,  params.gndtextureparams)% set figure stimulusfigwidth_pixels = NewStimViewingDistance * 2 *tan(params.figsize(1) /2 * pi/180) * pixels_per_cm;figheight_pixels = NewStimViewingDistance * 2 *tan(params.figsize(2) /2 * pi/180) * pixels_per_cm;% compute figure orientation rotation matrix% NO LONGER NECESSARY FOR PTB3, is done by DrawTextureangle = 0; % -params.figorientation * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute figure outlineif params.figshape == 2 % polygon    figpolygon = params.figpolygon;else    figpolygon = [0 0;        figwidth_pixels 0; ...        figwidth_pixels figheight_pixels;...        0 figheight_pixels;        0 0];end% rotate outlinefigpolygon = (rotation * figpolygon')';figpolygon = figpolygon - repmat(min(figpolygon),size(figpolygon,1),1); % to make positions positivefigrect = [min(figpolygon) max(figpolygon)];% compute moving direction rotation matrix%angle = (-params.figdirection+270) * pi /180 ;angle = 3/2*pi; %(params.figdirection/2 ) * pi /180 +3/2*pirotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute figure motion vectorunit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / params.framerate ;unit_motion_per_frame = -(rotation * [unit_motion_per_frame; 0])'; % in pixels, minus is to match periodicstimfigmotion_per_frame = unit_motion_per_frame * params.figspeed;  % in pixels% compute total figure motion to extend figure windowfigtotalmovingdistance = figmotion_per_frame * (n_movement_frames-n_movement_frames_without_figure);figtotalrect = round(figrect + [0 0 abs(figtotalmovingdistance(1)) abs(figtotalmovingdistance(2))]*2); % factor 2 is to use same rect for both forward and reverse motion% make large offscreen with figure stimulus%offscreen_fig = Screen(StimWindow,'OpenOffscreenWindow',255,figtotalrect);offscreen_fig = Screen('MakeTexture',StimWindow,zeros(figtotalrect(4),figtotalrect(3),'uint8'));% make screen transparent%Screen(offscreen_fig,'FillRect',transpt_clrind);% set drawing region, dependent on stimulus shapetempfigtext = params.figtextureparams;tempfigtext(4) = tempfigtext(4) - params.figorientation;fillwithtexture(offscreen_fig, figtxt_rgb, figbg_rgb,  tempfigtext)%gndpos = min([0 0],-gndmotion_per_frame*n_movement_frames);% CHECK NEXT STATEMENT: 2010-08-19gndpos = -abs(gndmotion_per_frame)*n_movement_frames;figpos = params.figcenter - mean(figpolygon);offscreen = zeros(1,n_frames);% make still frame (f=1) without figure% new offscreen%offscreen(1) = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 width height]);offscreen(1) = Screen('MakeTexture',StimWindow,zeros(height,width,'uint8'));% copy ground to offscreen%Screen('CopyWindow',offscreen_gnd,offscreen(1),...%	round([-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)]),[0 0 width height]);Screen('DrawTexture',offscreen(1),offscreen_gnd,...    round([-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)]),[0 0 width height]);% make still frame (f=2) with figure% new offscreenoffscreen(2) = Screen('MakeTexture',StimWindow,zeros(height,width,'uint8'));% copy ground to offscreenScreen('DrawTexture',offscreen(2),offscreen_gnd,...    [-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)],[0 0 width height]);% take region in figure src image that will not cross the imageboundary during% the movement%srcfigrect = figrect + repmat(figtotalmovingdistance.*(figtotalmovingdistance>0),1,2)% CHECK NEXT STATEMENT: 2010-08-19srcfigrect = figrect + repmat(abs(figtotalmovingdistance),1,2);blankscreen = zeros(height,width,'uint8');% set drawing regionswitch params.figshape    case 0        figdrawingregion = figrect + [figpos figpos];    otherwise        CloseStimScreen        error('LAMMESTIM:LOADSTIMPTB3: only rectangular figure shape is implemented.');end% copy figure to offscreenfigdrawingregion = fix(figdrawingregion);rec1 = fix(srcfigrect);rec2 = fix([figpos figpos] + figrect);[rec1,rec2] = cliprects(rec1,rec2,[0 0 inf inf]);[rec2,rec1] = cliprects(rec2,rec1,figdrawingregion);Screen('DrawTexture', offscreen(2), offscreen_fig,rec1,rec2,params.figorientation);for f=3:n_movement_frames+3 % moving frames    % ground movement    if params.ground_moves        gndpos = gndpos + gndmotion_per_frame;    end        % new offscreen    offscreen(f) = Screen('MakeTexture',StimWindow,blankscreen);    % copy ground to offscreen    rec1 = fix([-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)]);    rec2 = fix([0 0 width height]);    [rec1,rec2] = cliprects(rec1,rec2,[0 0 gndrectwidth gndrectheight]);    [rec2,rec1] = cliprects(rec2,rec1,[0 0 width height]);    Screen('DrawTexture',offscreen(f),offscreen_gnd,rec1,rec2);        if f-2 >n_movement_frames_without_figure        % figure movement        if params.figure_moves            if params.fixed_aperture                srcfigrect = srcfigrect - [figmotion_per_frame figmotion_per_frame];            else                % then entire figure moves, and thus the figdrawingregion                figdrawingregion = figdrawingregion + repmat( figmotion_per_frame,size(figdrawingregion,1),1);                figpos = figpos + repmat( figmotion_per_frame,size(figpos,1),1);            end        end                % copy figure to offscreen        %Screen(offscreen(f),'SetDrawingRegion',figdrawingregion,shapeFlag);        %Screen('CopyWindow',offscreen_fig,offscreen(f),...        %	srcfigrect,[figpos figpos] + figrect,'srcOr');        figdrawingregion = fix(figdrawingregion);        rec1 = fix(srcfigrect);        rec2 = fix([figpos figpos] + figrect);        [rec1,rec2] = cliprects(rec1,rec2,[0 0 inf inf]);        [rec2,rec1] = cliprects(rec2,rec1,figdrawingregion);        Screen('DrawTexture', offscreen(f), offscreen_fig,rec1,rec2,params.figorientation);        % for grabbing stim for presentation:        %global matcopy        %matcopy = Screen(offscreen(f),'getimage');        % later do save('tempfile','matcopy');            endend;% now translate into movie with refreshrate set by monitor% set framerate if there is open stimscreenif ~isempty(StimWindowRefresh)    dps.fps = StimWindowRefresh; % monitor framerateelse    error('LAMMESTIM/LOADSTIM: StimWindowRefresh is empty');endrefreshes_per_frame = dps.fps / params.framerate;%dps.frames = [...%	1*ones(1,n_still_frames_without_figure) ...%	2*ones(1,n_still_frames-n_still_frames_without_figure) ...%	3:n_movement_frames+1 ];dps.frames = [...    1*ones(1, round( n_still_frames_without_figure * refreshes_per_frame) ) ...    2*ones(1, round( (n_still_frames_before_movement-n_still_frames_without_figure) * refreshes_per_frame)   ) ...    round(linspace(3,n_movement_frames+3,(n_movement_frames-1)*refreshes_per_frame)) ...    (n_movement_frames+3)*ones(1, round( n_still_frames_after_movement * refreshes_per_frame))	];if isfield(dps,'defaults')    dps = rmfield(dps,'defaults');endstim = setdisplayprefs(stim,displayprefs(struct2vararg(dps)));dS = {'displayType', 'Movie', 'displayProc', 'standard', ...    'offscreen', offscreen, 'frames', n_frames, 'depth', 8, ...    'clut_usage', clut_usage, 'clut_bg', clut_bg, 'clut', clut};outstim = stim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);disp('LAMMESTIM/LOADSTIMPTB3: Stimulus loaded');returnfunction fillwithtexture(offscreen, txtcolor, bgcolor,textureparams)%NewStimGlobalsrect = Screen(offscreen,'Rect');rectwidth = rect(3)-rect(1);rectheight = rect(4)-rect(2);% compute texture elementstxtwidth = textureparams(1);txtlength = textureparams(2);txtdensity = textureparams(3);txtangle = textureparams(4);% compute rotation matrixangle = (-txtangle) * pi /180; % convert to degreesrotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];txtwidth_pixels = NewStimViewingDistance * 2*tan(txtwidth/2 *pi/180) * pixels_per_cm;txtlength_pixels = NewStimViewingDistance * 2*tan( txtlength/2 *pi/180) * pixels_per_cm;%txtextend = abs(rotation * [txtwidth_pixels txtlength_pixels]' )';txtarea = 2*txtlength_pixels*2*txtwidth_pixels;number_of_txts_to_fill_rect = rectheight * rectwidth / txtarea;n_txts = ceil(txtdensity * number_of_txts_to_fill_rect);%rf_clearance_radius_pixels = NewStimViewingDistance * 2* tan( params.rf_clearance_radius/2 *pi/180) * pixels_per_cm;txtbasepoints =...    [ -txtwidth_pixels -txtlength_pixels; ...    -txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels -txtlength_pixels ];txtbasepoints = (rotation * txtbasepoints')';txtpoints = cell(n_txts,1);for i = 1:n_txts    center_clear = 0;    while ~center_clear        %gndcenter = [gndrectleft+gndrectwidth*rand(1) gndrecttop+gndrectheight*rand(1)];%        txtcenter = [rectwidth*rand(1) rectheight*rand(1)]; % genereate random position        % still need to add full extend to this        txtpoints{i} = txtbasepoints + repmat(round(txtcenter),4,1);        center_clear = 1;        %		for j=1:4        %			if norm(txtpoints{i}(j,:)-params.figcenter) < rf_clearance_radius_pixels        %				center_clear = 0;        %				break;        %			end        %		end    endend% set background colorScreen(offscreen,'FillRect',bgcolor);  % becomes different when figure shape is different% draw texture stimulifor i=1:n_txts    Screen(offscreen,'FillPoly',txtcolor,txtpoints{i});endfunction [new1,new2] = cliprects(rec1,rec2,bound1)%makes rec1 stay within bound1 and clips rec1 and rec2 simulteanouslynew1 = rec1;new2 = rec2;if rec1(1)<bound1(1)    new1(1) = bound1(1);    new2(1) = new2(1) - (rec1(1)-bound1(1)) ;endif rec1(2)<bound1(2)    new1(2) = 0;    new2(2) = new2(2) - (rec1(2)-bound1(2));endif rec1(3)>bound1(3)    new1(3) = bound1(3);    new2(3) = new2(3) - (rec1(3)-bound1(3)) ;endif rec1(4)>bound1(4)    new1(4) = bound1(4);    new2(4) = new2(4) - (rec1(4)-bound1(4)) ;end
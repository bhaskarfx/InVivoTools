function [outstim] = loadstimPTB3(stim)%lammestim/loadstim%%% everything is setup by loadstim for movement of both figure and ground,% but stimulus' typenumber determinus which parts actually move% this takes more memory, but it was by far the easiest way to ensure% that the onset stimuli are identical for all cases.%% if gnddirection=NaN, figdirection is used for gndirection%%% lamme modulation index: (4+5)/(3+6)%% 2012, Alexander Heimel%StimWindowGlobals;NewStimGlobals;stim = unloadstim(stim);  % unload old version before loadingparams = stim.params;% fill in NaN parametersif isnan(params.gndspeed)    params.gndspeed = params.figspeed;endif isnan(params.gnddirection)    params.gnddirection = params.figdirection;endif isnan(params.figtextureparams(4))    params.figtextureparams(4) = params.figdirection;endif isnan(params.gndtextureparams)    params.gndtextureparams = params.figtextureparams;    params.gndtextureparams(4) = params.gnddirection;endif isnan(params.figorientation)    params.figorientation = params.figdirection;endif isnan(params.movement_duration)    if params.movement_onset>=0        params.movement_duration = params.duration - params.movement_onset;    else        params.movement_duration = 0;    endendif params.reverse_figdirection    params.figdirection = params.figdirection + 180;endif params.reverse_gnddirection    params.gnddirection = params.gnddirection + 180;end% set texture or gratingif isfield(params,'imageType') && ~isempty(params.imageType) && params.imageType~=9    usegrating = true;else     usegrating = false;endwidth  = params.rect(3) - params.rect(1);height = params.rect(4) - params.rect(2);% set initial random staterand('state',params.randState); %#ok<RAND>% set BG, figure and ground colorsfigbg_rgb = params.figbg;figtxt_rgb = figbg_rgb * (1+ params.figcontrast );gndbg_rgb = params.gndbg;gndtxt_rgb = gndbg_rgb * (1+params.gndcontrast);clut_bg = repmat(params.BG,256,1);clut_usage = [];clut = repmat( (0:255)',1,3);% check MovieParams2MTIds_userfield.Movie_globalalphas = [];ds_userfield.Movie_sourcerects = [];dp = getdisplayprefs(stim.stimulus);dps = struct(dp);% params.framerate contains the stimulus framerate% this is lower than monitor rate to reduce memory load% but with PTB3 it is no longer necessary and thus no longer used.n_frames = ceil(params.duration * StimWindowRefresh);n_still_frames_before_movement = round(params.movement_onset * StimWindowRefresh);n_still_frames_without_figure = round( min(params.figure_onset, params.movement_onset) * StimWindowRefresh);n_movement_frames = round(params.movement_duration * StimWindowRefresh);n_movement_frames_without_figure = round(max(0,(params.figure_onset - params.movement_onset)) * StimWindowRefresh);n_still_frames_after_movement = n_frames - n_still_frames_before_movement - n_movement_frames;ShowStimScreen;% set ground stimulus% compute moving direction rotation matrixangle = (-params.gnddirection+270) * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute motion vectorunit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / StimWindowRefresh;unit_motion_per_frame = -(rotation * [unit_motion_per_frame; 0])'; % in pixels, minus is to match periodicstimgndmotion_per_frame = unit_motion_per_frame * params.gndspeed;  % in pixelsgndtotalmovingdistance = abs(gndmotion_per_frame) * n_movement_frames;gndrectwidth = width + gndtotalmovingdistance(1)*2; % factor 2 is to use same rect for both forward and reverse motiongndrectheight = height;gnddestwidth = width * sin(params.gnddirection*pi/180) + height * cos(params.gnddirection*pi/180);gnddestheight = height * sin(params.gnddirection*pi/180) + width * cos(params.gnddirection*pi/180);% make large offscreen with ground stimulusif usegrating    offscreen_gnd =  makegrating( params.imageType,params.gndtextureparams,gndrectwidth );else    offscreen_gnd = Screen('MakeTexture',StimWindow,zeros(gndrectheight+1,gndrectwidth+1,'uint8'));    fillwithtexture(offscreen_gnd, gndtxt_rgb, gndbg_rgb,  params.gndtextureparams)end% set figure stimulusfigwidth_pixels = NewStimViewingDistance * 2 *tan(params.figsize(1) /2 * pi/180) * pixels_per_cm;figheight_pixels = NewStimViewingDistance * 2 *tan(params.figsize(2) /2 * pi/180) * pixels_per_cm;% compute figure orientation rotation matrixangle = 0; % -params.figorientation * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute figure outlineif params.figshape == 2 % polygon    figpolygon = params.figpolygon;else    figpolygon = [0 0;        figwidth_pixels 0; ...        figwidth_pixels figheight_pixels;...        0 figheight_pixels;        0 0];end% rotate outlinefigpolygon = (rotation * figpolygon')';figpolygon = figpolygon - repmat(min(figpolygon),size(figpolygon,1),1); % to make positions positivefigrect = [min(figpolygon) max(figpolygon)];% compute moving direction rotation matrix%angle = (-params.figdirection+270) * pi /180 ;if usegrating    angle = 0;else    angle = 3/2*pi; %(params.figdirection/2 ) * pi /180 +3/2*piendrotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute figure motion vectorunit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / StimWindowRefresh ;unit_motion_per_frame = -(rotation * [unit_motion_per_frame; 0])'; % in pixels, minus is to match periodicstimfigmotion_per_frame = unit_motion_per_frame * params.figspeed;  % in pixels% compute total figure motion to extend figure windowfigtotalmovingdistance = figmotion_per_frame * (n_movement_frames-n_movement_frames_without_figure);figtotalrect = round(figrect + [0 0 abs(figtotalmovingdistance(1)) abs(figtotalmovingdistance(2))]*2); % factor 2 is to use same rect for both forward and reverse motion% make large offscreen with figure stimulusif usegrating    offscreen_fig =  makegrating( params.imageType,params.figtextureparams,max(figtotalrect) );else    offscreen_fig = Screen('MakeTexture',StimWindow,zeros(figtotalrect(4),figtotalrect(3),'uint8'));        % set drawing region, dependent on stimulus shape    tempfigtext = params.figtextureparams;    tempfigtext(4) = tempfigtext(4) - params.figorientation;    fillwithtexture(offscreen_fig, figtxt_rgb, figbg_rgb,  tempfigtext)endgndpos = -abs(gndmotion_per_frame)*n_movement_frames;figpos = params.figcenter - mean(figpolygon);% Make frames% texture 1 is background% texture 2 is figuretexgnd = 1;texfig = 2;% make still frame without figurefor f = 1:n_still_frames_without_figure    ds_userfield.Movie_textures{f} = texgnd;    ds_userfield.Movie_sourcerects(:,f,texgnd) = round([-gndpos(1) -gndpos(2) gnddestwidth-gndpos(1) gnddestheight-gndpos(2)]);    ds_userfield.Movie_destrects(:,f,texgnd) = [0 0 gnddestwidth gnddestheight];    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gndtextureparams(4)+90;end% make still frames with ground and figure% take region in figure src image that will not cross the imageboundary during% the movementsrcfigrect = figrect + repmat(abs(figtotalmovingdistance),1,2);figdrawingregion = fix( figrect + [figpos figpos] );rec1 = fix(srcfigrect);rec2 = fix([figpos figpos] + figrect);[rec1,rec2] = cliprects(rec1,rec2,[0 0 inf inf]);[rec2,rec1] = cliprects(rec2,rec1,figdrawingregion);for f = (n_still_frames_without_figure+1) : n_still_frames_before_movement    ds_userfield.Movie_textures{f} = [texgnd texfig];    ds_userfield.Movie_sourcerects(:,f,texgnd) = round([-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)]);    ds_userfield.Movie_destrects(:,f,texgnd) = [0 0 gnddestwidth gnddestheight];    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    if usegrating        ds_userfield.Movie_angles(1,f,texgnd) = params.gndtextureparams(4)+90;    end        ds_userfield.Movie_sourcerects(:,f,texfig) = rec1;    ds_userfield.Movie_destrects(:,f,texfig) = rec2;    ds_userfield.Movie_angles(1,f,texfig) = params.figorientation;    ds_userfield.Movie_globalalphas(1,f,texfig) = 1;endfor f=(n_still_frames_before_movement+1):(n_movement_frames+n_still_frames_before_movement+1) % moving frames    % ground movement    if params.ground_moves        gndpos = gndpos + gndmotion_per_frame;    end        % copy ground     rec1 = fix([-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)]);    rec2 = fix([0 0 width height]);    [rec1,rec2] = cliprects(rec1,rec2,[0 0 gndrectwidth gndrectheight]);    [rec2,rec1] = cliprects(rec2,rec1,[0 0 width height]);    ds_userfield.Movie_textures{f} = [texgnd texfig];    ds_userfield.Movie_sourcerects(:,f,texgnd) = rec1;    ds_userfield.Movie_destrects(:,f,texgnd) = [0 0 gnddestwidth gnddestheight];    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    if usegrating        rec2 = fix([-width -height width height]);        ds_userfield.Movie_destrects(:,f,texgnd) = rec2;        ds_userfield.Movie_angles(1,f,texgnd) = params.gndtextureparams(4)+90;    end    if f-n_still_frames_before_movement >n_movement_frames_without_figure        % figure movement        if params.figure_moves            if params.fixed_aperture                srcfigrect = srcfigrect - [figmotion_per_frame figmotion_per_frame];            else                % then entire figure moves, and thus the figdrawingregion                figdrawingregion = figdrawingregion + repmat( figmotion_per_frame,size(figdrawingregion,1),1);                figpos = figpos + repmat( figmotion_per_frame,size(figpos,1),1);            end        end                % copy figure to offscreen        figdrawingregion = fix(figdrawingregion);        rec1 = fix(srcfigrect);        rec2 = fix([figpos figpos] + figrect);        [rec1,rec2] = cliprects(rec1,rec2,[0 0 inf inf]);        [rec2,rec1] = cliprects(rec2,rec1,figdrawingregion);                ds_userfield.Movie_sourcerects(:,f,texfig) = rec1;        ds_userfield.Movie_destrects(:,f,texfig) = rec2;        ds_userfield.Movie_angles(1,f,texfig) = params.figorientation;        ds_userfield.Movie_globalalphas(1,f,texfig) = 1;        % for grabbing stim for presentation:        %global matcopy        %matcopy = Screen(offscreen(f),'getimage');        % later do save('tempfile','matcopy');    endend;for f=(n_movement_frames+n_still_frames_before_movement+2):(n_movement_frames+n_still_frames_before_movement+1)  +n_still_frames_after_movement% moving frames    rec1 = fix([-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)]);    rec2 = fix([0 0 width height]);    [rec1,rec2] = cliprects(rec1,rec2,[0 0 gndrectwidth gndrectheight]);    [rec2,rec1] = cliprects(rec2,rec1,[0 0 width height]);    ds_userfield.Movie_textures{f} = [texgnd texfig];    ds_userfield.Movie_sourcerects(:,f,texgnd) = rec1;    ds_userfield.Movie_destrects(:,f,texgnd) = rec2;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    figdrawingregion = fix(figdrawingregion);    rec1 = fix(srcfigrect);    rec2 = fix([figpos figpos] + figrect);    [rec1,rec2] = cliprects(rec1,rec2,[0 0 inf inf]);    [rec2,rec1] = cliprects(rec2,rec1,figdrawingregion);        ds_userfield.Movie_sourcerects(:,f,texfig) = rec1;    ds_userfield.Movie_destrects(:,f,texfig) = rec2;    ds_userfield.Movie_angles(1,f,texfig) = params.figorientation;    ds_userfield.Movie_globalalphas(1,f,texfig) = 1;end% now translate into movie with refreshrate set by monitor% set framerate if there is open stimscreenif ~isempty(StimWindowRefresh)    dps.fps = StimWindowRefresh; % monitor framerateelse    error('LAMMESTIM/LOADSTIM: StimWindowRefresh is empty');endn_frames = size(ds_userfield.Movie_sourcerects,2);dps.frames = (1:n_frames);if isfield(dps,'defaults')    dps = rmfield(dps,'defaults');endstim = setdisplayprefs(stim,displayprefs(struct2vararg(dps)));dS = {'displayType', 'Movie', 'displayProc', 'standard', ...    'offscreen', [offscreen_gnd,offscreen_fig], 'frames', n_frames, 'depth', 8, ...    'clut_usage', clut_usage, 'clut_bg', clut_bg, 'clut', clut, ...    'clipRect', [] , 'makeClip', 0,'userfield',ds_userfield };outstim = stim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);disp('LAMMESTIM/LOADSTIMPTB3: Stimulus loaded');returnfunction offscreen =  makegrating( imageType, txtparams, width_offscreen )NewStimGlobalsStimWindowGlobalssFrequency = 1/(2*txtparams(1)); % using barwidth (deg) as half cycledistance = NewStimViewingDistance;sPhaseShift = 0; % radwLeng = (distance * tan((pi/180))/sFrequency) * pixels_per_cm;  % units: pixels per cyclepixelIncrement = 2*pi/wLeng;phase = mod( sPhaseShift + (0:pixelIncrement:(width_offscreen-1)*pixelIncrement) , 2*pi);  % 1-D grating phase as a function of spaceswitch imageType,	case 0,  % field		grating = 1;	case 1, % square wave		grating = -1+2*double(cos(phase)>0);	case 2, % sine wave		grating = cos(phase);	case 3, % triangle		grating = -1+2*(abs(phase - pi)/pi);	case 4, % light saw		grating = -1+2*(2*pi-phase)/(2*pi);	case 5, % dark saw		grating = -1+2*phase/(2*pi);	case 6, % bars		grating = double(phase<(ps.PSparams.barWidth*2*pi))*2*(ps.PSparams.barColor-0.5);	case 7, % edge, like lightsaw but with bars determining width of saw		phasemod = phase;		phasemod(phase<ps.PSparams.barWidth*2*pi) = 0;		nonzerovalues = find(phase>=ps.PSparams.barWidth*2*pi);		phasemod(nonzerovalues) = 1-rescale(phase(nonzerovalues),[min(phase(nonzerovalues)) max(phase(nonzerovalues))],[0 1]);		grating = phasemod;	case 8, % bump (bars with internal smooth dark->light->dark transitions (sinusoidal)		phasemod = phase;		phasemod(phase>=ps.PSparams.barWidth*2*pi) = 0;		phasemod = sin(-pi/2+2*pi*phasemod./max(phasemod));		phasemod(phase>=ps.PSparams.barWidth*2*pi) = 0;		grating = phasemod;    case 9, % texture            disp('LAMMESTIM/LOADSTIMPTB3: imageType texture should be handled elsewhere');	otherwise,		error(['Unknown image type imageType']);end;colors.low_rgb = [0 0 0];colors.high_rgb = [255 255 255];img_colorized = cat(3,...    rescale(grating,[-1 1],[colors.low_rgb(1) colors.high_rgb(1)]),...	rescale(grating,[-1 1],[colors.low_rgb(2) colors.high_rgb(2)]),...	rescale(grating,[-1 1],[colors.low_rgb(3) colors.high_rgb(3)]));offscreen = Screen('MakeTexture',StimWindow,img_colorized);function fillwithtexture(offscreen, txtcolor, bgcolor,textureparams)%NewStimGlobalsrect = Screen(offscreen,'Rect');rectwidth = rect(3)-rect(1);rectheight = rect(4)-rect(2);% compute texture elementstxtwidth = textureparams(1);txtlength = textureparams(2);txtdensity = textureparams(3);txtangle = textureparams(4);% compute rotation matrixangle = (-txtangle) * pi /180; % convert to degreesrotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];txtwidth_pixels = NewStimViewingDistance * 2*tan(txtwidth/2 *pi/180) * pixels_per_cm;txtlength_pixels = NewStimViewingDistance * 2*tan( txtlength/2 *pi/180) * pixels_per_cm;%txtextend = abs(rotation * [txtwidth_pixels txtlength_pixels]' )';txtarea = 2*txtlength_pixels*2*txtwidth_pixels;number_of_txts_to_fill_rect = rectheight * rectwidth / txtarea;n_txts = ceil(txtdensity * number_of_txts_to_fill_rect);%rf_clearance_radius_pixels = NewStimViewingDistance * 2* tan( params.rf_clearance_radius/2 *pi/180) * pixels_per_cm;txtbasepoints =...    [ -txtwidth_pixels -txtlength_pixels; ...    -txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels -txtlength_pixels ];txtbasepoints = (rotation * txtbasepoints')';txtpoints = cell(n_txts,1);for i = 1:n_txts    center_clear = 0;    while ~center_clear        %gndcenter = [gndrectleft+gndrectwidth*rand(1) gndrecttop+gndrectheight*rand(1)];%        txtcenter = [rectwidth*rand(1) rectheight*rand(1)]; % genereate random position        % still need to add full extend to this        txtpoints{i} = txtbasepoints + repmat(round(txtcenter),4,1);        center_clear = 1;        %		for j=1:4        %			if norm(txtpoints{i}(j,:)-params.figcenter) < rf_clearance_radius_pixels        %				center_clear = 0;        %				break;        %			end        %		end    endend% set background colorScreen(offscreen,'FillRect',bgcolor);  % becomes different when figure shape is different% draw texture stimulifor i=1:n_txts    Screen(offscreen,'FillPoly',txtcolor,txtpoints{i});endfunction [new1,new2] = cliprects(rec1,rec2,bound1)%makes rec1 stay within bound1 and clips rec1 and rec2 simulteanouslynew1 = rec1;new2 = rec2;if rec1(1)<bound1(1)    new1(1) = bound1(1);    new2(1) = new2(1) - (rec1(1)-bound1(1)) ;endif rec1(2)<bound1(2)    new1(2) = 0;    new2(2) = new2(2) - (rec1(2)-bound1(2));endif rec1(3)>bound1(3)    new1(3) = bound1(3);    new2(3) = new2(3) - (rec1(3)-bound1(3)) ;endif rec1(4)>bound1(4)    new1(4) = bound1(4);    new2(4) = new2(4) - (rec1(4)-bound1(4)) ;end